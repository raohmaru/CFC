# Python Scripts for the Card Fighters' Clash definition for OCTGN
# Copyright (C) 2022 Raohmaru

# This python script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this script. If not, see <http://www.gnu.org/licenses/>.

#---------------------------------------------------------------------------
# General functions
#---------------------------------------------------------------------------

def num(s):
   if not s:
      return 0
   try:
      return int(s)
   except ValueError:
      return 0


def waitForAnimation():
   """
   Delays the next action until all animation is done.
   https://github.com/octgn/OCTGN/issues/412
   https://github.com/octgn/OCTGN/issues/110
   """
   # rnd() is generated by the server and synch with all players
   rnd(100, 10000)
   # Forces any pending networked tasks to complete before executing next line
   # update()


def funcCall(player, func, args = []):
   """
   Invokes a function for the given player.
   """
   if player == me:
      func(*args)
   else:
      remoteCall(player, func.__name__, args)


def unique(seq):
   """
   Returns a list with values not repeated.
   """
   seen = set()
   # Because Python is dynamic, accessing variables is faster than attribute lookup
   seen_add = seen.add
   return [x for x in seq if not (x in seen or seen_add(x))]


def getGlobalVar(name, player = None):
   """
   Gets a game global variable or a player global variable.
   """
   if player:
      id = player._id
      if not id in PlayerGlobals:
         PlayerGlobals[id] = {}
      if not name in PlayerGlobals[id]:
         PlayerGlobals[id][name] = eval(player.getGlobalVariable(name))
      # Returns a copy so it cannot be modified
      return eval(str(PlayerGlobals[id][name]))
   else:
      if not name in Globals:
         Globals[name] = eval(getGlobalVariable(name))
      # Returns a copy so it cannot be modified
      return eval(str(Globals[name]))


def setGlobalVar(name, value, player = None):
   """
   Sets a game global variable or a player global variable.
   """
   gvar = getGlobalVar(name, player)
   if player:
      PlayerGlobals[player._id][name] = value
   else:
      Globals[name] = value
   if len(players) > 1:
      # Changes in a list variable that contains dicts
      if isinstance(gvar, list):
         if len(gvar) > 0 and isinstance(gvar[0], dict) or len(value) > 0 and isinstance(value[0], dict):
            remov = [v for v in gvar if v not in value]
            added = [v for v in value if v not in gvar]
            value = (remov, added)
      # Changes in a dict variable
      elif isinstance(gvar, dict):
         diff = set(gvar) ^ set(value)
         remov = [k for k in diff if k not in value]
         added = [{k:value[k]} for k in diff if k not in gvar]
         # Possible updated fields
         diff = set(gvar) & set(value)
         added += [{k:value[k]} for k in diff if gvar[k] != value[k]]
         value = (remov, added)
      # 0 is the fake player of the tutorial
      if players[1]._id != 0:
         remoteCall(players[1], "updateSharedGlobals", [name, value, player])


def clearGlobalVar(name, player = None):
   gvar = getGlobalVar(name, player)
   if isinstance(gvar, list):
      del gvar[:]  # Clear list
   elif isinstance(gvar, dict):
      gvar.clear()
   elif isinstance(gvar, basestring):
      gvar = ''
   elif isinstance(gvar, (int, long)):
      gvar = 0
   setGlobalVar(name, gvar, player)
         
         
def updateSharedGlobals(name, value, player = None):
   """
   Replacement for OCTGN global variables, because when simultaneous requests are sent from different players to update a
   global variable, the server does not merge the data and keeps only the last updated version.
   """
   # Merge current variable with the changes from the other player
   if isinstance(value, tuple):
      remov, added = value
      gvar = getGlobalVar(name, player)
      # list
      if isinstance(gvar, list):
         gvar = [v for v in gvar if v not in remov]
         value = gvar + added
      # dict
      elif isinstance(gvar, dict):
         for k in remov:
            del gvar[k]
         for d in added:
            gvar.update(d)
         value = gvar
   if player:
      if not player._id in PlayerGlobals:
         PlayerGlobals[player._id] = {}
      PlayerGlobals[player._id][name] = value
   else:
      Globals[name] = value


#---------------------------------------------------------------------------
# String functions
#---------------------------------------------------------------------------

def fromWhereStr(group, srcPlayer = me):
   """
   Returns a textual representation of the player's group from where an effect takes place.
   """
   if group == table:
      return "from the ring"
   else:
      ctrl = "its"
      # If the source of the effect is not the current player, then the name of the current player
      # is used to avoid confusion in the log
      if group.controller == me and srcPlayer != me:
         ctrl = "{}'s".format(me)
      elif srcPlayer != me:
         ctrl = "{}'s".format(srcPlayer)
      elif group.controller != me:
         ctrl = "{}'s".format(group.controller)
      # Gets the current ongoing effect
      effect = getTempVar("effect")
      if effect and effect[2] and effect[2]["pick"] is not None and effect[2]["pick"] < 0:
         ctrl = "the bottom of " + ctrl
         
      return "from {} {}".format(ctrl, group.name)

   
def sanitizeStr(str):
   """
   Strips the string, replaces spaces with dashes and removes characters not in [a-z0-9\-].
   """
   valid_chars = "-abcdefghijklmnopqrstuvwxyz0123456789"
   str = str.strip().lower().replace(" ", "-")
   str = "".join(c for c in str if c in valid_chars)
   return str
   

def pluralize(num):
   if num == 1:
      return ""
   return "s"
   

def cardsAsNamesListStr(cards):
   """
   Returns a string with the names of the cards separated by commas.
   """
   if not cards:
      return ""
   if len(cards) == 1:
      return "{}".format(cards[0])
   arr = list(cards[:-1])
   str = ("{}, " * len(arr)).format(*arr)[:-2]
   str += " and {}".format(cards[-1])
   return str
      

def replIdsWithNames(string):
   """
   Replaces a card ID in the string (e.g. {#66526}) with the card name, to be used in forms.
   """
   return re.sub(Regexps["cardid"], lambda match: Card(int(match.group(1))).Name, string)
   
   
def stringify(obj):
   """
   Converts an object into a string representation prefixed by its type.
   """
   if isCard(obj):
      return "{c}" + str(obj._id)
   elif isPlayer(obj):
      return "{p}" + str(obj._id)
   else:
      return obj


def objectify(value):
   """
   Converts a formated string into an object.
   """
   if isinstance(value, basestring):
      if value[:3] == "{c}":
         return Card(int(value[3:]))
      elif value[:3] == "{p}":
         return Player(int(value[3:]))
   return value
   